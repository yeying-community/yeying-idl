syntax = "proto3";
option go_package = "yeying/api/asset";
package yeying.api.asset;

import "yeying/api/common/message.proto";
import "yeying/api/common/code.proto";

/**

开放的分散式仓库网络的接口设计，参考了现实世界中的仓库，逻辑如下：
1、数字资产有两个标识，一个是数字资产的身份标识，可以是分布式数字身份，也可以是用户自定义的身份ID，另一个是数字资产内容的哈希值；
2、数字资产入库，发送到指定存储网络中的节点，可以指定副本数量，一方面保证内容不会因为单个节点故障而丢失，另外也保证内容的可访问性；
3、存储复用，如果两份资产哈希值一样，分两种情况来看，如果资产的所有者一样，则仓库会主动告知身份持有者存在重复，如果资产的所有者不同，会增加引用；
4、授权数字资产，所有者和使用者立交易关系，确保使用者根据指定的策略访问数据，仓库会统计数字资产的使用情况，比如统计内容取（浏览）的次数评估内容热度
，或者统计内容存的次数（收藏）评估内容质量，目的是更好的分配存储资源；

分散式存储网络的使用场景：
1、创作场景，知识产权证明
2、代码包分发场景，比如软件包，模型包等
3、数字资产，类似nft等
 */
service Asset {
  /**
   * 检索数字内容，基于数字内容的元信息检索，比如时间、类型、名称等, 如果什么条件都不传入，则按照默认的排序顺序，返回第一个10条记录。
   */
  rpc Search(SearchRequest) returns (SearchResponse) {}

  /**
   * 以事务的形式和存储供应商签订协议并入库，当所有资产块入库成功后，资产的信息发送到后端服务签字确认，涵盖了新的资产和新的版本入库；
   * 1、根据规则，自动生成新的版本，资产身份不变，但是资产内容的哈希值会变
   */
  rpc Sign(SignRequest) returns (SignResponse) {}

  /**
   * 查看某个资产的版本
   */
  rpc Version(VersionRequest) returns (VersionResponse) {}

  /**
   * 获得资产详细信息，提供该接口是为了更灵活处理资产信息，资产信息的复杂主要是几个方面：
   * 1、资产分块，资产的块信息可能会很大
   * 2、多版本，资产描述信息也会很大
   * 3、分散存储，如果资产过大，可能会被存储到不同的供应商
   */
  rpc Detail(DetailRequest) returns (DetailResponse) {}

  /**
   * 从当前仓储网络移除掉数字内容；
   */
  rpc Remove(RemoveRequest) returns (RemoveResponse) {}

  /**
   * 前端浏览器不支持client stream，提供一个非流式的上传接口
   */
  rpc Put(PutRequest) returns (PutResponse) {}

  /**
   * 前端浏览器不支持server stream，提供一个非流式的下载接口
   */
  rpc Get(GetRequest) returns (GetResponse) {}

  /**
   * 分块入库数字内容，正常的入库流程:1，发送chunk的简要信息；2，上传资产块的内容；3，确认资产块的完整信息；
   */
  rpc StreamPut(stream StreamPutRequest) returns (PutResponse) {}

  /**
   * 分块出库数字内容
   */
  rpc StreamGet(GetRequest) returns (stream StreamGetResponse) {}
}

message SearchRequest {
  string condition = 1;
  common.DigitalFormatEnum format = 2;
}

message SearchResponse {
  common.ResponseStatus status = 1;
  repeated AssetMetadata assets = 2;
}

// 先发送内容，然后发送的chunk元信息，
message StreamPutRequest {
  oneof data {
    // 资产块头信息
    PutHeader header = 1;
    // 资产块内容
    bytes body = 2;
  }
}

message PutHeader {
  // 资产ID
  string assetId = 2;
  // 资产块元信息
  ChunkMetadata chunk = 3;
}

message PutRequest {
  // 资产块头信息
  PutHeader header = 1;
  // 资产块内容
  bytes body = 2;
}

message PutResponse {
  common.ResponseStatus status = 1;
  // 当前传输的资产块
  ChunkMetadata chunk = 2;
}

enum Action {
  OVERWRITE = 0;
  APPEND = 1;
}

// 版本统一由后端服务器来生成或者变更，和仓库签约的资产版本，必须是最新的版本号
message SignRequest {
  // 资产元信息
  AssetMetadata asset = 1;
  // 覆盖老的，还是追加
  Action action = 2;
}

message SignResponse {
  common.ResponseStatus status = 1;
  AssetMetadata asset = 2;
}

message VersionRequest {
  // 资产ID
  string assetId = 1;
}

message VersionResponse {
  common.ResponseStatus status = 1;
  repeated AssetMetadata assets = 2;
}

message DetailRequest {
  // 资产哈希值
  string assetHash = 1;
}

message DetailResponse {
  common.ResponseStatus status = 1;
  AssetMetadata asset = 2;
}

message GetRequest {
  string assetMergedHash = 1;
  string chunkHash = 2;
}

message StreamGetResponse {
  common.ResponseStatus status = 1;
  oneof data {
    GetHeader header = 2;
    bytes body = 3;
  }
}

message GetHeader {
  ChunkMetadata chunk = 1;
}

message GetResponse {
  common.ResponseStatus status = 1;
  GetHeader header = 2;
  bytes body = 3;
}

message RemoveRequest {
  string assetHash = 2;
}

message RemoveResponse {
  common.ResponseStatus status = 1;
  AssetMetadata asset = 2;
}

// 资产块信息
message ChunkMetadata {
  // 块在资产中的索引
  uint32 index = 1;
  // 明文块哈希值
  string hash = 2;
  // 明文块大小
  uint64 size = 3;
  // 块的扩展信息
  string extend = 4;
}

// 资产定义
message AssetMetadata {
  string owner = 1;
  // 资产版本
  uint32 version = 2;
  // 资产ID
  string id = 3;
  // 资产名称
  string name = 4;
  // 基线资产的哈希值，针对变更场景，从那个资产派生出来了
  string parentHash = 5;
  // 资产哈希值
  string hash = 6;
  // 资产块合并的哈希值，验证数据一致性，如果资产内容小于块的大小，和资产哈希值一样
  string mergedHash = 7;
  // 资产描述
  string description = 8;
  // 资产类型
  common.DigitalFormatEnum format = 9;
  // 明文资产的大小
  uint64 size = 10;
  // 资产创建时间
  string created = 11;
  // 资产更新时间点
  string checkpoint = 12;
  // 资产内容分成多少块
  uint32 total = 13;
  // 资产块的大小
  uint32 block = 14;
  // 是否加密
  bool encrypted = 15;
  // 资产扩展信息
  string extend = 16;
  // 资产块信息
  repeated ChunkMetadata chunks = 17;
}