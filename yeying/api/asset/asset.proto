syntax = "proto3";
option go_package = "yeying/api/asset";
package yeying.api.asset;

import "yeying/api/common/message.proto";
import "yeying/api/common/code.proto";

/**

开放的分散式仓库网络的接口设计，参考了现实世界中的仓库，逻辑如下：
1、数字资产有两个标识，一个是数字资产的身份标识，可以是分布式数字身份，也可以是用户自定义的身份ID，另一个是数字资产内容的哈希值；
2、数字资产入库，发送到指定存储网络中的节点，可以指定副本数量，一方面保证内容不会因为单个节点故障而丢失，另外也保证内容的可访问性；
3、存储复用，如果两份资产哈希值一样，分两种情况来看，如果资产的所有者一样，则仓库会主动告知身份持有者存在重复，如果资产的所有者不同，会增加引用；
4、授权数字资产，所有者和使用者立交易关系，确保使用者根据指定的策略访问数据，仓库会统计数字资产的使用情况，比如统计内容取（浏览）的次数评估内容热度
，或者统计内容存的次数（收藏）评估内容质量，目的是更好的分配存储资源；

分散式存储网络的使用场景：
1、创作场景，知识产权证明
2、代码包分发场景，比如软件包，模型包等
3、数字资产，类似nft等
 */
service Asset {
  /**
   * 检索数字内容，基于数字内容的元信息检索，比如时间、类型、名称等, 如果什么条件都不传入，则按照默认的排序顺序，返回第一个10条记录。
   */
  rpc Search(SearchRequest) returns (SearchResponse) {}

  /**
   * 以事务的形式和存储供应商签订协议并入库，当所有资产块入库成功后，资产的信息发送到后端服务签字确认，涵盖了新的资产和新的版本入库；
   * 1、自动生成新的版本，资产身份不变，但是资产内容的哈希值会变
   */
  rpc Sign(SignRequest) returns (SignResponse) {}

  /**
   * 获得资产详细信息，提供该接口是为了更灵活处理资产信息，资产信息的复杂主要是几个方面：
   * 1、资产分块，资产的块信息可能会很大
   * 2、多版本，资产描述信息也会很大
   * 3、分散存储，如果资产过大，可能会被存储到不同的供应商
   */
  rpc Detail(DetailRequest) returns (DetailResponse) {}

  /**
   * 从当前仓储网络移除掉数字内容；
   */
  rpc Remove(RemoveRequest) returns (RemoveResponse) {}

  /**
   * 前端浏览器不支持client stream，提供一个非流式的上传接口
   */
  rpc Put(PutRequest) returns (PutResponse) {}

  /**
 * 前端浏览器不支持server stream，提供一个非流式的下载接口
 */
  rpc Get(GetRequest) returns (GetResponse) {}

  /**
   * 分块入库数字内容，正常的入库流程:1，发送chunk的简要信息；2，上传资产块的内容；3，确认资产块的完整信息；
   */
  rpc StreamPut(stream StreamPutRequest) returns (PutResponse) {}

  /**
   * 分块出库数字内容
   */
  rpc StreamGet(GetRequest) returns (stream StreamGetResponse) {}
}

message SearchRequest {
  string did = 1;
  string condition = 2;
  common.DigitalFormat format = 3;
}

message SearchResponse {
  common.ResponseStatus status = 1;
  repeated AssetMetadata assets = 2;
}

// 先发送内容，然后发送的chunk元信息，
message StreamPutRequest {
  oneof data {
    // 资产块头信息
    Header header = 1;
    // 资产块内容
    bytes body = 2;
  }
}

message PutRequest {
  // 资产块头信息
  Header header = 1;
  // 资产块内容
  bytes body = 2;
}

message PutResponse {
  common.ResponseStatus status = 1;
  // 当前传输的资产块
  ChunkMetadata chunk = 2;
}

message SignRequest {
  string did = 1;
  AssetMetadata asset = 2;
}

message SignResponse {
  common.ResponseStatus status = 1;
  AssetMetadata asset = 2;
}

message DetailRequest {
  string did = 1;
  // 资产身份
  string assetDid = 2;
  // 资产哈希值
  string hash = 3;
}

message DetailResponse {
  common.ResponseStatus status = 1;
  repeated AssetMetadata assets = 2;
}

message GetRequest {
  string did = 1;
  string hash = 2;
}

message StreamGetResponse {
  oneof data {
    Header header = 1;
    bytes body = 2;
  }
}

message GetResponse {
  Header header = 1;
  bytes body = 2;
}

message RemoveRequest {
  string did = 1;
  string hash = 2;
}

message RemoveResponse {
  common.ResponseStatus status = 1;
  AssetMetadata asset = 2;
}

message Header {
  // 上传者身份
  string did = 1;
  // 资产身份
  string assetDid = 2;
  // 资产块元信息
  ChunkMetadata chunk = 3;
}

// 资产块信息
message ChunkMetadata {
  // 块在资产中的索引
  uint32 index = 1;
  // 明文块哈希值
  string hash = 2;
  // 明文块大小
  uint64 size = 3;
  // 块的扩展信息
  string extend = 4;
}

// 资产定义
message AssetMetadata {
  uint32 version = 1;
  // 每个资产在上传时，需要生成一个分布式数字身份，目前考虑到方案的成熟度，可以使用uuid代替；TODO：需要考虑分布式数字身份信息存在哪里；
  string did = 2;
  // 资产名称
  string name = 3;
  // 资产哈希值
  string hash = 4;
  // 资产块合并的哈希值，验证数据一致性，如果资产内容小于块的大小，和资产哈希值一样
  string mergedHash = 5;
  // 资产描述
  string description = 6;
  // 资产类型
  common.DigitalFormat format = 7;
  // 明文资产的大小
  uint64 size = 8;
  // 资产创建时间
  string created = 9;
  // 资产更新时间点
  string checkpoint = 10;
  // 资产内容分成多少块
  uint32 total = 11;
  // 资产块的大小
  uint32 block = 12;
  // 是否加密
  bool encrypted = 13;
  // 资产扩展信息
  string extend = 14;
  // 资产块信息
  repeated ChunkMetadata chunks = 15;
}